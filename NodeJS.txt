				Node.js

What is node?
Why node?
Node.js Architecture
 -High level
 -low level

What is Node? /Node.js?
    Node is javascript runtime and platform.
By using node we can run js code outside browser

Why Node?
 ->Process
 ->Threading Models
 ->IO architecture

Process:
 It is program which runs the other program.
eg: CLR is process which runs .net code/app
    jvm is process which runs java code
    node is process which runs js code

Threading Model:
  Every process has thread.
 CLR AND JVM is multi threaded
   YOu can created threads, also runtimes hosts its own thread - main thread.

IO architecture:
  IO means read and write.

Node was to created to build "IO Applications"

Types of IO Applications

1.File system io apps
   app can read and write data from and to "hard disk"
2.Networking io apps
   Web server is io apps, which reads data from the network and sends data via       network.
   TCP server
   UDP Server
   Data gram server
3.Process IO/Memory
   read and write data from and into "RAM" 


Other languages also can help to implement IO Applications.
  .net 
     FileSystem name space to read and write data from disk
  .net 
     MVC architecture is used to read and write data from and to network

What is the core difference between other language and node.js with respect io?

			Non Blocking IO
.....................................................................................

File descriptor:
 file descriptor is c program (ds) which holds all io informations.

if a program is going to talk to keyword,monitor.
  fd holds the references to keyboard,monitor.


Linux non blocking apis

1.select -  2000
2.poll 
3.epoll - modern event notification api 


Linux is the first os who introduced nonblocking io apis

After Linux, Windows,mac, other BSD os also had introduced nonblocking apis

windows-iocp
linux -epoll
mac - kqueue
.....................................................................................
			 First Non blocking webserver


ngix webserver was the first non blocking webserver which was created and tested on linux.
.....................................................................................
			 Node.js as non blocking io wrapper
.....................................................................................

In 2007, Node.js was created to build non blocking io applications using javascript.

....................................................................................
			 Node.js non blocking arch


Node.js provides two major components

1.js runtime which is from google - V8
2.libuv runtime which is plaform abstraction lib for making non blocking io calls.

Node.js and threading model:
...........................

There are two threading model

1.non blocking thread /event loop threads/main thread

    - To handle non blocking network io calls

2.blocking thread/worker loop thread
      -To handle non blockig file io calls and blocking io calls, user code

....................................................................................
Node.js Programming area

1.Node REPL
2.Node and js apis
3.Node core apis
4.Styles of writing async programming
   ->Callback pattern
   ->Promise Pattern
   ->Promise with Async and await Pattern


...................................................................................

1.Node REPL - Read Evalulate Print loop

Node REPL is used to run js programs interactive mode.

Js programs are executed in two modes

1.interactive mode - REPL mode
2.script mode - by loading script on to the runtime

1.interactive mode - REPL mode
C:\Users\subu>node
Welcome to Node.js v20.11.1.
Type ".help" for more information.
> 10 +10
20
> new Date()
2024-07-13T10:55:31.010Z
> JSON.stringify({id:1})
'{"id":1}'
> a=10
10
> b=20
20
> c = a + b
30
>

Can you use all js features inside node?

No

Browser objects such document,window,storage....

> window
Uncaught ReferenceError: window is not defined
>

In browser window is super object

In node what is super object?
  Process- Object
 process - it is variable holds Process object
 window - It is variable holds WIndow object
...................................................................................
			Async programming and styles -non blocking app
...................................................................................

project setup:
G:\DSS>mkdir mynodeapp

G:\DSS>cd mynodeapp

G:\DSS\mynodeapp>mkdir src

G:\DSS\mynodeapp>

G:\DSS\mynodeapp>code .

G:\DSS\mynodeapp>node src/index.js
hello node

Fundamental Requirement:
........................

1.OS should support non blocking apis like select,poll,epoll

2.Program languages/platforms also should provide high level apis to map os low level apis

In order to write non blocking apps in js(node), we have different patterns(styles)

Nonblocking Applications Developement style:
............................................

1.callbacks
2.Promises
3.Async await
4.reactive programming 

1.callbacks:
  Callback is listener function which gets registered during compile time
  and exexcuted during runtime when ever the event is emitted.

Req for async programming:
 
1.You need high level non blocking api - provided by node.js 
2.listener api which is called "function as parameter/hof" 

HOF functions are becoming listeners/callbacks which are called when ever event is emitted.

NonBlocking apis:
1.timer
   -setTimeout -
   -setInterval
2.io
   web
   fs
   socket
 etc...
3.process api
  nextTick

Use case: blocking code:
//blocking : functions are getting called in sequence

function blockMe(message) {
    console.log(message)
}
function sayHello() {
    console.log('hello')
}
function main() {
    blockMe('start')
    sayHello()
    blockMe('end')
}
main()

Use case: how to turn into non blocking.
 
Steps:
1.introduce non blocking api called timer
2.add listner - hof - pass fun as parameter
3.call that function once async operation is completed

Timer:
 timer will invoke after certain timeout.

//blocking : functions are getting called in sequence

function blockMe(message) {
    console.log(message)
}
function sayHello(callback) {
    // callback()
    //introduce non block api - timer
    setTimeout(callback, 5000)
}
function main() {
    blockMe('start')
    sayHello(function () {
        console.log('hello')
    })
    blockMe('end')
}
main()
...................................................................................
			Callback Chaining /Callback composition
..................................................................................

Sequentional Programming:
.........................

result = apicall
result2  apicall(result)

The out put of one api call will be input to another api call -  chaining.

How to chain in nonblocking env?


const getUser = (resolve, reject) => {
    console.log('getUser is called')
    let user = { name: 'admin' }
    //user=null
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, 'User not found')
    }

}
const login = (user, resolve, reject) => {
    console.log('login is called')
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, 'login success')
    } else {
        setTimeout(reject, 1000, 'login failed')
    }
}
const showdashboard = (status, resolve, reject) => {
    console.log('showdashboard is called')
    if (status === 'login success') {
        setTimeout(resolve, 1000, 'welcome')
    } else {
        setTimeout(reject, 1000, 'oops!Try again')
    }
}
function main() {
    getUser((user) => {
        login(user, (status) => {
            showdashboard(status, (msg) => {
                console.log(msg)
            }, (err) => {
                console.log(err)
            })
        }, (err) => {
            console.log(err)
        })
    }, (err) => {
        console.log(err)
    })
}
main()
....................................................................................
				Callback Hell
....................................................................................


function main() {
    getUser(user => {
        login(user, status => {
            showDashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })

}
main()
....................

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No
 "Callback Hell"

Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which   called as "Callback Hell".
.....................................................................................
		IS There is better solution is available to write
			non blocking code
			without callbacks
....................................................................................

Yes!

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.

In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

What is Promise?

 "Promise is design pattern" which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.
.....................................................................................
.....................................................................................
			  Promise Implementation
.....................................................................................

Features of Promise Object:
1.Promise by deafult is Async. Which implements timer api with 0 ms .
2.Promise can be used with any async callback based  implementations.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Difference between callbacks and promises:

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.

....................................................................................

		Promise Implemenation: Object Object creations
...................................................................................

1. Create Promise Object from Promise contructor
      new Promise()
2. Create Promise object from factory apis 
      Promise.resolve() / Promise.reject()

Promise object methods:

1.then - success
2.catch - errors
3.finally - clean up

factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race


1.Promise factory api
   -success - resolve
   -failure - reject


//basic promise implementation:
//In promises , you dont need to pass function as parameter

Promise with Success and also ensure that Promise is async.


Use case: Promise is by default async


//simple

function blockMe(message) {
    console.log(message)
}
function sayHello() {
    //by default async
    return Promise.resolve('hello')
}
function main() {
    blockMe('start')
    sayHello().then(res => console.log(res))
    blockMe('end')
}
main()

Use case: promise with error

//simple

function blockMe(message) {
    console.log(message)
}
function getError() {
    //by default async
    return Promise.reject('oops')
}
function main() {
    blockMe('start')
    getError().catch(err => console.log(err))
    blockMe('end')
}
main()

use case : error /success : simple biz logic
function blockMe(message) {
    console.log(message)
}
function login(name) {
    if (name === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login Failed')
    }
}

blockMe('start')

login('admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))

login('foo')
    .then(status => console.log(status))
    .catch(err => console.log(err))
    
blockMe('end')
..................................................................................
			2.Promise Constructor Api
....................................................................................

i want to return users after 1000ms
if i want to wrap any existing callback based program into promise based 

 "You have to use Promise Constructor Pattern"

function blockMe(message) {
    console.log(message)
}
function login(name) {
    return new Promise((resolve, reject) => {
        if (name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}

blockMe('start')

login('admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))

login('foo')
    .then(status => console.log(status))
    .catch(err => console.log(err))

blockMe('end')
....................................................................................
			Callback Hell and Promises
...................................................................................



const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = { name: 'admin' }
        //user=null
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, 'User not found')
        }
    })

}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}
const showdashboard = status => {
    console.log('showdashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'welcome')
        } else {
            setTimeout(reject, 1000, 'oops!Try again')
        }
    })
}
function main() {
    // getUser((user) => {
    //     login(user, (status) => {
    //         showdashboard(status, (msg) => {
    //             console.log(msg)
    //         }, (err) => {
    //             console.log(err)
    //         })
    //     }, (err) => {
    //         console.log(err)
    //     })
    // }, (err) => {
    //     console.log(err)
    // })

    // getUser()
    //     .then(user => {
    //         return login(user)
    //     })
    //     .then(status => {
    //         return showdashboard(status)
    //     }).then(page => {
    //         console.log(page)
    //     })
    //     .catch(err => console.log(err))

    getUser()
        .then(user => login(user))
        .then(status => showdashboard(status)).then(page => console.log(page))
        .catch(err => console.log(err))
}
main()
.....................................................................................
				Promise Hell
.....................................................................................

getUser()
        .then(user => login(user))
        .then(status => showdashboard(status)).then(page => console.log(page))
        .catch(err => console.log(err))

Here we are using many thens "thenables" which makes your code still complex to read,debug,maintain.

There is solution called "async ... await" keywords.
 Which does not replace promise rather , it simplfies to handle promises.

In order reduce thenables, ES 7 Introduced new key words to abstract promise then and catch are "async and await"

async keyword:

1.in front of function we use async keyword, meaning that the function returns promise by default with success only.



async function getValue() {
    return 10 // Promise.resolve(10)
}
function main() {
    const value = getValue()
    console.log(value)

    getValue().then(value=>console.log(value))
}
main()

await keyword:

 1.replace then and catch, make async code looks like sync code
 2.await keyword can be used only inside async functions.



const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = { name: 'admin' }
        //user=null
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, 'User not found')
        }
    })

}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}
const showdashboard = status => {
    console.log('showdashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'welcome')
        } else {
            setTimeout(reject, 1000, 'oops!Try again')
        }
    })
}
async function main() {
    // getUser()
    //     .then(user => login(user))
    //     .then(status => showdashboard(status)).then(page => console.log(page))
    //     .catch(err => console.log(err))

    try {
        const user = await getUser()
        const status = await login(user)
        const page = await showdashboard(status)

        console.log(user,status,page)
    }
    catch (err) {
        console.log(err)

    }
}
main()
.....................................................................................
				Modules Pattern
...................................................................................


In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java

What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd:2005 on wards
4.ES 6 Module design pattern:2012-2015  = amd + cjs
------------------------------------------------------------
5.System :2007 = AMD = CJS + ES 6
6.UMD :2008 = NAMESPACE + AMD + CJS = ES 6
....................................................................................

....................................................................................
				Commonjs-CJS
.....................................................................................

How to share code? How to import code?

 Code:
  Could be variables,functions,classes.
  Variables can have any literal string,numbers,boolean,objects,functions...

src
  |
  subfolders
|
index.js

Sharing code :

Keywords
exports
module.exports

Imporing code:

require('fileName')
require('folderName/fileName')

exports:
 Used to share more code from the single file.
 exports packs the entire code into one single js object and returns that object

//pack the code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan'
exports.salary = 1000
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java','JavaScript','Node.js']


require:
  It is a function which returns what ever we exported from the file.

const obj= require('fileName')



src/util.myutil.js

//pack the code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan'
exports.salary = 1000
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java', 'JavaScript', 'Node.js']
exports.saySomething = () => "something"

src/index.js
//access the code from the myutil.js 
const res = require('./util/myutil')
console.log(res)

console.log(`${res.firstName} ${res.lastName} ${res.address.city} ${res.salary}`)
console.log(`${res.skills} ${res.status} ${res.saySomething()}`)

....................................................................................
				module.exports
....................................................................................

Export only one item from the file.

eg"
 if you want to share  "Class"
 if you want to share "array"
 if you want to share "Object"

const customerService = require('./services/CustomerService')

async function main() {
    //     customerService.findAll(customers => {
    //         console.log(customers)
    //     })

    //promise then 
    //customerService.findAll().then(customers => console.log(customers)).catch(err => console.log(err))
    try {
        const customers = await customerService.findAll()
        console.log(customers)
    }
    catch (err) {
        console.log(err)
    }
}
main()

src/services/customer.service.js


class CustomerService {
    constructor() {

    }
    //sync api
    // findAll() {
    //     return [{ id: 1, name: 'a' }]
    // }
    //callback based
    // findAll(callback) {
    //     setTimeout(callback, 1000, [{ id: 1, name: 'a' }])
    // }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, [{ id: 1, name: 'a' }])
        })
    }
}
//share class
//module.exports = CustomerService
//share object
module.exports = new CustomerService()
.....................................................................................
			 ES 6 Module pattern
.....................................................................................

ES 6 module pattern = CJS

To share code

export   = exports (cjs)
export default = module.exports (cjs)

To link code

import - require('') (cjs)

Commonjs and es6 module cant be mixed in single project.

src/lib/utility.js

export const firstName = 'Subramanian'

src/index.js
import { firstName } from "./lib/utility";

console.log(firstName)

G:\DSS\es6Modules>node src/index.js
(node:6824) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
(Use `node --trace-warnings ...` to show where the warning was created)
G:\DSS\es6Modules\src\index.js:1
import { firstName } from "./lib/utility";
^^^^^^

SyntaxError: Cannot use import statement outside a module
    at internalCompileFunction (node:internal/vm:77:18)
    at wrapSafe (node:internal/modules/cjs/loader:1288:20)
    at Module._compile (node:internal/modules/cjs/loader:1340:27)
    at Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
    at Module.load (node:internal/modules/cjs/loader:1207:32)
    at Module._load (node:internal/modules/cjs/loader:1023:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:135:12)
    at node:internal/main/run_main_module:28:49

Node.js v20.11.1


Why this error?
  Node.js does not support es 6 module directly.

Solution:(how to run es6 modules in node)

1.you have to convert es6 code into cjs code using build tools
2.latest node supports es6 with configuration.
   2.1.inside package.json file
      "type": "module"
   
  npm init --yes
 
   2.2. file can be saved "fileName.mjs" extension
  "type": "module"

final code
src/index.js
import { firstName } from "./lib/utility.js";

console.log(firstName)
...................................................................................

src/lib/greet.mjs
export default function sayGreet(message) {
    return message
}

.....................................................................................
			Types of modules
.....................................................................................

1.Custom module
  built by us
2.built in modules
   provided by node.js  
3.provided by third party/community
  libs,frameworks


OperatingSystem:
//os
const os = require('node:os')
console.log(os.arch())
console.log(os.cpus())

./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('node:os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('node:os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}
.....................................................................................
				  Events

Node.js is event driven arch, some program emits events called emitter and some program lisents for those events called "listeners".

Using events module we can build event programming model.

As of now , we are going to discuss simple events with in objects, later in microservices we will see the distributed event driven arch.

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.

For instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.			



const EventEmitter = require('node:events')

class Sales extends EventEmitter {
    constructor() {
        super()
        //register listener
        this.on('sold', (evt) => {
            console.log('Got Event')
            console.log(evt)
        })
    }

    sale(product) {
        //emitter
        this.emit('sold', product)
    }
}

function main() {
    let sales = new Sales()
    sales.sale({ id: 1, name: 'product', qty: 100, price: 100 })
}
main()
...................................................................................
			   IO Modules
...................................................................................

1.file system io
   file system io , how to read data from disk file
2.network io


File System IO:
=>We can read and write files from the disk in  two ways
  1.blocking way
  2.nonblocking way
=>We can read and write files using two mode
  1.NonStreaming mode
  2.Streaming mode
=>All file operations are handled by
  "Worker Threads" from Worker Thread Pool - either it is blocking or non blocking    io.
=>Files are handled using callback style or promise style.
=>Files operations are handled by "fs" module

How to read File using nonblocking pattern? using callbacks

fs.readFile(path[, options], callback)

path <string> | <Buffer> | <URL> | <integer> filename or file descriptor
options <Object> | <string>
 encoding <string> | <null> Default: null
 flag <string> See support of file system flags. Default: 'r'.
 signal <AbortSignal> allows aborting an in-progress readFile

callback <Function>
  err <Error> | <AggregateError>
  data <string> | <Buffer>


//const fs =require('node:fs')

import { readFile } from 'node:fs'

function blockMe(message) {
    console.log(message)
}
function main() {
    const filePath = './src/assets/info.txt'

    const options = {
        encoding: 'UTF-8'
    }

    blockMe('start')
    readFile(filePath, options, (err, data) => {
        if (err) throw err
        console.log(data)
    })
    blockMe('end')

}
main()

Task:
 Conver the callback code into Promise code.


Use Case: Builtin promise package:

import { readFile } from 'node:fs/promises'

async function main() {
    const filePath = './src/assets/info.txt'
    const options = {
        encoding: 'UTF-8'
    }
    // readFile(filePath, options)
    //     .then(data => console.log(data))
    //     .catch(err => console.log(err))
    try {
        const data = await readFile(filePath, options)
        console.log(data)
    }
    catch (err) {
        console.log(err)
    }


}
main()
.....................................................................................		How to read File using blocking pattern?
....................................................................................

import { readFileSync } from 'node:fs'

async function main() {
    const filePath = './src/assets/info.txt'
    const options = {
        encoding: 'UTF-8'
    }
    console.log('start')
    const data = readFileSync(filePath, options)
    console.log(data)
    console.log('end')
}
main()
....................................................................................
			
		How to use path module? and global variables
....................................................................................


The path module provides utilities for working with file and directory paths.

-node provides lot of global variables

__dirname  : current directory name
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src

__filename :current directory name + fileName
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src\index.js


const { readFile } = require('node:fs')
const { join } = require('node:path')

// const filePath = './src//assets/info.txt'
const filePath = join(__dirname, 'assets/info.txt')

const options = {
    encoding: 'UTF-8'
}
function blockMe(message) {
    console.log(message)
}
//async api to read file
blockMe('start')
readFile(filePath, options, (err, data) => {
    if (err) throw err
    console.log(data)
})
blockMe('end')
.....................................................................................
			Mode of fs read and write
.....................................................................................

1.Non Streaming Mode

2.Streaming  Mode

1.Non Streaming Mode

  only file io is supported, network io not supported

 -once file is read, the entire file is loaded into node process buffer(memory), then it will be delivered to caller.

-if more files are loaded into node process, node process gets crashed.

-non streaming mode is not suitable for large and big files read or write operation.

fs.readFile() and fs.writeFile are non streaming apis.


2.Streaming apis:
   supported by fs and also network apis


-Streaming is nothing but flow of data(chunks).
-Streaming allows move the data from one place to another place one by one.
-Streaming apis are other wise called evented io. which is powered events.



Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write

Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr

All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

Common events in all io
.........................


1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

4.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.


Use case : To read file using input stream

import { createReadStream } from 'node:fs'

const filePath = './src/assets/info.txt'

const options = {
    encoding: 'UTF-8'
}

const inputStream = createReadStream(filePath, options)

//attach events : listeners
//attach events for io 
let data = ''
inputStream.on('data', chunk => {
    console.log('data event is called')
    data += chunk
})

inputStream.on('end', () => {
    console.log('end event is called')
    console.log(data)
})
inputStream.on('close', () => {
    console.log('close event is called')
})
inputStream.on('error', (err) => {
    console.log('error event', err)
})
..........

Writing file using Stream:
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})


.....................................................................................
				Back Pressure
....................................................................................

When input stream and output stream works together.

Backpressure:
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


How to handle back pressure?

 apis  : pause,resume,drain event

pause : to close the upstream, not to emit data
resume : to open the open upstream , to emit data

drain event: if drain event is called, means buffer is empty
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);


readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});

writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});		

....................................................................................
			 Using Pipe
...................................................................................
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputFileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
.....................................................................................
			HTTP programming
....................................................................................
Node was created to build non blocking web server and web applications.
Node provides single event loop thread which handles lot of concurrent http requests.
Node offers high level http wrapper apis to talk to os apis.
Node offers http as object.

HTTP Objects

1.Agent -  http.Agent
  For handling connections between and server

2.ClientRequest - http.clientRequest
  For creating http clients

3.Server - http.Server
  For creating web servers,we can create app and deploy on top of server.
  
4.ServerResponse - http.ServerResponse
  ServerResponse is outputstream of "http socket"

5.IncomingMessage -http.IncomingMessage
    The payload which is sent by client -  Message

6.OutgoingMessage -http.OutgoingMessage
    The data which is sent by server - Message

7.Global Methods of http
  
 1.createServer
    factory method to create http server instance.

HTTP events:
 
 There are three types of events

1.HTTP Request events
  Which are triggered whenever client request is recived by server

request.on('nameoftheevent',listner)

2.Http Response events
   Which are triggered whenever server response is sent by server

response.on('nameoftheevent',listner)

3.Server Events
   Server events are triggered during server startup,connection,handshake,request

 server.on('nameoftheevent',listner)

common events:
data,close,end,error

Note:
 Each Object has its own events apart from common events.



{
  _connectionListener: [Function: connectionListener],
  METHODS: [
    'ACL',         'BIND',       'CHECKOUT',
    'CONNECT',     'COPY',       'DELETE',
    'GET',         'HEAD',       'LINK',
    'LOCK',        'M-SEARCH',   'MERGE',
    'MKACTIVITY',  'MKCALENDAR', 'MKCOL',
    'MOVE',        'NOTIFY',     'OPTIONS',
    'PATCH',       'POST',       'PROPFIND',
    'PROPPATCH',   'PURGE',      'PUT',
    'REBIND',      'REPORT',     'SEARCH',
    'SOURCE',      'SUBSCRIBE',  'TRACE',
    'UNBIND',      'UNLINK',     'UNLOCK',
    'UNSUBSCRIBE'
  ],
  STATUS_CODES: {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': "I'm a Teapot",
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '509': 'Bandwidth Limit Exceeded',
    '510': 'Not Extended',
    '511': 'Network Authentication Required'
  },
  Agent: [Function: Agent] { defaultMaxSockets: Infinity },
  ClientRequest: [Function: ClientRequest],
  IncomingMessage: [Function: IncomingMessage],
  OutgoingMessage: [Function: OutgoingMessage],
  Server: [Function: Server],
  ServerResponse: [Function: ServerResponse],
  createServer: [Function: createServer],
  validateHeaderName: [Function: __node_internal_],
  validateHeaderValue: [Function: __node_internal_],
  get: [Function: get],
  request: [Function: request],
  setMaxIdleHTTPParsers: [Function: setMaxIdleHTTPParsers],
  maxHeaderSize: [Getter],
  globalAgent: [Getter/Setter]
}

////////////////////////////////////////////////////////////////////

First Web Server: Helloworld
const http = require('node:http')

//create server

const server = http.createServer((req, res) => {
    //handle client request and send response
    res.write('Hello')
    res.end()
})

//start server
server.listen(3000, () => {
    console.log('Server is Ready')
})

Use case: only end Method:
const http = require('node:http')

//create server

const server = http.createServer((req, res) => {
    res.end('hello')
})

//start server
server.listen(3000, () => {
    console.log('Server is Ready')
})

How to attach events?

Server events:
  request -event.

const http = require('node:http')

//create server

const server = http.createServer((req, res) => {
    res.end('hello')
})

//start server
server.listen(3000, () => {
    console.log('Server is Ready')
})

//attac server listener
server.on('request', (req, res) => {
    //console.log(req)
    console.log('Request Recived on', new Date(), "URL is", req.url, "method ", req.method)
})
..............................................................................
				How to send json?
.................................................................................
const http = require('node:http')

//create server

const server = http.createServer((req, res) => {
    const body = [{
        message: 'Hello'
    }, {
        message: 'Hai'
    }]
    res.writeHead(200, {
        'Content-Type': 'application/json',
    });
    res.end(JSON.stringify(body))
})

//start server
server.listen(3000, () => {
    console.log('Server is Ready')
})

//attac server listener
server.on('request', (req, res) => {
    //console.log(req)
    console.log('Request Recived on', new Date(), "URL is", req.url, "method ", req.method)
})
.....................................................................................
			Modularzation and Web
.....................................................................................
src/services/user.service.js

const USERS = require("../mock-data/users")

class UserService {

    //apis 
    findAll() {
        const userJson = JSON.stringify(USERS)
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, userJson)
        })
    }

}

module.exports = new UserService()

src/index.js
const http = require('node:http')
const { findAll } = require('./services/user.service')

//create server

const server = http.createServer(async (req, res) => {

    try {
        res.writeHead(200, {
            'Content-Type': 'application/json',
        });
        const users = await findAll()
        res.end(users)
    }
    catch (err) {
        res.writeHead(400, {
            'Content-Type': 'application/json',
        });
        res.end({ err: err })
    }
})

//start server
server.listen(3000, () => {
    console.log('Server is Ready')
})

//attac server listener
server.on('request', (req, res) => {
    //console.log(req)
    console.log('Request Recived on', new Date(), "URL is", req.url, "method ", req.method)
})
.....................................................................................
			How to get Input
....................................................................................
const http = require('node:http')
const { save } = require('./services/user.service')

//create server

const server = http.createServer((req, res) => {

    let data = ''
    req.on('data', (chunk) => {
        data += chunk
    })
    req.on('end', async () => {
        res.writeHead(201, {
            'Content-Type': 'application/json',
        });
        //invoke
        const result = await save(JSON.parse(data))
        res.end(JSON.stringify({ status: result }))
    })

})

//start server
server.listen(3000, () => {
    console.log('Server is Ready')
})

//attac server listener
server.on('request', (req, res) => {
    //console.log(req)
    console.log('Request Recived on', new Date(), "URL is", req.url, "method ", req.method)
})
.....................................................................................
				.....................................................................................
		   Building RestFull web services
.....................................................................................

1.Resources
   Customer,Product,Item,Payment
2.API
   findAll,findBYId,update,Remove,filter

3.URL 
   Resources and apis must be indentified by URL

4.APIs are mapped against HTTP verbs
  Read - GET
  Save  -POST
  update - PUT
  remove -  DELETE


Each Resource is identified by unique url

  /api/customer
  /api/products

Each Resource has collection of apis and which mapped against HTTP verbs

 findAll - GET


Having core node.js http module we cant build production ready webservices with minimum code, we need to write plenty of boiler plate code.

Node.js team in the begining started working on an abstraction called "framework"
			   "Express.js"
...................................................................................
				NPM
.....................................................................................

What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm to share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.

NPM consists of three components
1.the website - used to discover packages, setup profiles and manage other aspects of npm

2.CLI runs from the terminal, and how most developers interact with npm.

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a file or directory that is described by a "package.json" file
   A package must contain package.json file in order to be published to the npm    registry

Package format:
a.A folder containing a program described by a package.json.
b.A gizpped tarball containing "a"
c.A URL that resolves "a"

Modules:
 A module is any file or directory in the "node_modules" directory that can be loaded by the node.js require function

 A javascript file

modules need not have "package.json" file

eg:
 const http =require('http')

 here the variable called http referes the 'http' module.

....................................................................................
				How to create npm package

Steps:

1.create folder
>mkdir mynpm-apps
>cd mynpm-apps
>mkdir src

2.create package.json

Before create you have to ensure that npm has been installed.

npm init <initalizer>

npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.


package.json

{
  "name": "mynpmapps",
  "version": "1.0.0",
  "description": "This is demo package",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "my",
    "demo",
    "package"
  ],
  "author": "Subramanian Murugan",
  "license": "ISC"
}

name:
 This is used to publish package into registry

version:
   if you publish package into registry, which is differentiated by "version"

"1.0.0" - version no is based on the concept called "SEM Ver" concept- Semantic versioning.
 Major.minor.patch

main:
  It is main file used /entry file in the package , generally it would index.js or main.js

description:
  It explains the nature of packages- what is this packge.

Keywords:
  Used to discover your packages using npm search command

author:
  Who is author of this package

license:
  You should specify a license for your package so that people know how they are permitted to use it.
.................................................................................
.................................................................................
			   node_modules
.................................................................................

  it is folder , used to install any node packages, the node programm always looks up the packages from the current folder.

....................................................................................
....................................................................................
				Node Packages

How to install node packages which was distributed by others?

npm install [<package-name>]

You can find out the packages from npm registry server

npm install | i  lodash --options

npm i lodash 

No options are given by default "--save"

Options:

 --save
     for production + dev
 --save-dev
     -for only for dev 
 --production
    -for only production
  -g
    -for tool purpose -dev


Application mode

1.dev
2.test
3.prod

dev : any dependency required for development only
  --save-dev
test : 
   any dependency required for development only - test
   --save-dev
prod:
  dependency used in dev and production... 
  --save
"dependencies": {
    "lodash": "^4.17.21"
  }
..................................................................................
			 Test /Dev Only Dependency
.................................................................................

Libs required for dev and test
tools
   -compilers,webservers
   -testing libs and framworks 

eg:
  mocha - test runner is used for running test case
  chai.js -test assertion lib used for writing test cases
  jest -  test runner is used for running test cases

 "devDependencies": {
    "chai": "^4.3.6"
  }
....................................................................................

How to use?

src/index.js

const _ = require('lodash')

console.log(_)

....................................................................................
	  How to install only production dependencies during build process
....................................................................................
if you want to use app in production mode, you have exclude the dependencies.

npm i /npm install - install dev and production packages...
 --->it scans package.json file which install everything(dev + prod)

npm install --production
  it scans package.json which install only from  production dependencies
or
npm install --omit=dev
  it scans package.json which install only from  production dependencies			
..................................................................................
			 Test /Dev Only Dependency
.................................................................................

Libs required for dev and test
tools
   -compilers,webservers
   -testing libs and framworks 

eg:
  mocha - test runner is used for running test case
  chai.js -test assertion lib used for writing test cases
  jest -  test runner is used for running test cases

 "devDependencies": {
    "chai": "^4.3.6"
  }
....................................................................................
				
....................................................................................
	  How to install only production dependencies during build process
....................................................................................
if you want to use app in production mode, you have exclude the dependencies.

npm i /npm install - install dev and production packages...
 --->it scans package.json file which install everything(dev + prod)

npm install --production
  it scans package.json which install only from  production dependencies
.....................................................................................
.....................................................................................
....................................................................................
			How to remove /uninstall package

npm uninstall mocha --save-dev
,,,,,,,,,,,,,........................................................................

Global package is installed not inside project, installed globally.
Global packages are generally tools to create projects,webservers,test runtime like so.
npm install nodemon -g
npm install mocha -g
npm install create-react-app -g


etc...

....................................................................................
			 scripts
....................................................................................
 if you want to automat the js app workflows, scripts section is used.

scripts has ,script command and task to be executed.

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

test - is command
"echo \"Error: no test specified\" && exit 1" - task to be executed

in npm we have many built in commands.
eg
 start
 stop
 publish
 test
 pack
 postinstall
 preinstall
etc..
https://docs.npmjs.com/cli/v8/using-npm/scripts#npm-rebuild

Use case :
 We can run node apps using scripts
 we can run webservers using scripts
 we can initalize the test env using scripts
 we can start containers using scripts
 etc...

how to execute scripts commands?

npm commandName
eg
npm start
npm test
npm pack
etc..

npm allows even custom commands

subu:"task"
build:""
deploy:""
compile:""

if you want to custom script command?

npm run commandName
npm run subu
npm run build

eg:
 How to node app using npm?

How to run js ?

 node src/index.js

 npm commandName - npm start.

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/index.js",
    "dev": "node src/index.js"
  },

>npm start

>npm run dev.....................................................................................
			Global Modules and scripts
.....................................................................................

Tools we have installed globally like nodemon.

In order to avoid version mismatch, we can install any tools(webservers,compilers,utilites) as local module.

npm install nodemon -save-dev

After installing,nodemon is not available to execute like 

nodemon src/index.js
Error:
nodemon' is not recognized as an internal or external command,
operable program or batch file.

How to run nodemon?
 via scripts.
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon src/index.js",
    "build": "node src/index.js"
  },
.....................................................................................
Can i use tools like webserver,compiler,code generator without even installing inside project as dev?

npx command

Either local or global module we need to install, it occupies some amount memory.
if you want to execute tools with latest version always,you have to upgrade, instead of upgrading , we can directly execute the latest version of binary.

npx
.....................................................................................

Alternate to npm

1.npx
2.yarn
3.npmn
.....................................................................................
			 














